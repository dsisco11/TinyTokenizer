todo

# Green Node Flags Refactor (Precursor)

Goal: add a compact flags bitmask to green nodes so newline/comment/whitespace/error/keyword/tagged-ident checks are O(1) and enable subtree pruning.

Scope:
- Precursor to the Query newline optimization plan.
- Green layer only (TinyTokenizer/TinyTokenizer/Ast/Green*). No query changes in this work item.

Constraints:
- Green nodes remain immutable + structurally shareable.
- Flags must be deterministically derived from immutable content (trivia + children), never mutated.
- Preserve semantics: newline flags reflect `TriviaKind.Newline` only.

------------------------------------------------------------------------

## Phase 0 — Decide Flag Semantics (one-time)


Decisions (grounded in current AST model):
- Trivia kinds are exactly: `Whitespace` (spaces/tabs), `Newline` (\n / \r\n), `SingleLineComment`, `MultiLineComment`.
- Keywords are represented as nodes with `NodeKind` in the keyword range (`NodeKindExtensions.IsKeyword()`).
- Tagged identifiers are leaf nodes with `NodeKind.TaggedIdent`.
- Errors are leaf nodes with `NodeKind.Error`.

- [x] Confirm high-ROI flag set (v1)
	- [ ] Boundary trivia flags
		- [ ] `HasLeadingNewlineTrivia` / `HasTrailingNewlineTrivia`
		- [ ] `HasLeadingCommentTrivia` / `HasTrailingCommentTrivia`
		- [ ] `HasLeadingWhitespaceTrivia` / `HasTrailingWhitespaceTrivia`
	- [ ] Subtree flags
		- [ ] `ContainsNewlineTrivia`
		- [ ] `ContainsCommentTrivia`
		- [ ] `ContainsWhitespaceTrivia`
		- [ ] `ContainsErrorNode`
		- [ ] `ContainsKeyword`
		- [ ] `ContainsTaggedIdent`

- [x] Confirm boundary meaning for containers
	- [x] “Leading” refers to the left boundary of the node’s text span
	- [x] “Trailing” refers to the right boundary of the node’s text span
	- [x] For containers, boundary flags derive from first/last leaf boundaries (not necessarily immediate delimiter leaves for all container types)

Flag semantics (implementation-ready):
- Boundary flags:
	- `HasLeadingNewlineTrivia`: node’s left boundary has trivia of kind `Newline`.
	- `HasTrailingNewlineTrivia`: node’s right boundary has trivia of kind `Newline`.
	- `HasLeadingWhitespaceTrivia`: left boundary has trivia kind `Whitespace` (explicitly excludes `Newline`).
	- `HasTrailingWhitespaceTrivia`: right boundary has trivia kind `Whitespace`.
	- `HasLeadingCommentTrivia`: left boundary has trivia kind `SingleLineComment` OR `MultiLineComment`.
	- `HasTrailingCommentTrivia`: right boundary has trivia kind `SingleLineComment` OR `MultiLineComment`.
	- Leaf rule: boundary flags are computed by scanning `GreenLeaf.LeadingTrivia` / `GreenLeaf.TrailingTrivia`.
	- Container rule: boundary flags are derived from the first/last leaf descendant boundaries (fast once flags exist). For `GreenBlock`, this effectively comes from opener/closer delimiter leaves.

- Subtree flags:
	- `ContainsNewlineTrivia`: any leaf in the subtree has newline trivia (leading or trailing).
	- `ContainsWhitespaceTrivia`: any leaf in subtree has whitespace trivia.
	- `ContainsCommentTrivia`: any leaf in subtree has comment trivia.
	- `ContainsErrorNode`: any node in subtree has `Kind == NodeKind.Error`.
	- `ContainsKeyword`: any node in subtree has `Kind.IsKeyword()`.
	- `ContainsTaggedIdent`: any node in subtree has `Kind == NodeKind.TaggedIdent`.

Acceptance criteria:
- Flag list and boundary semantics are written down and stable.

------------------------------------------------------------------------

## Phase 1 — Add Flags Infrastructure

- [x] Add `GreenNodeFlags` enum (bitmask)
	- [x] Pick underlying type (`ushort` vs `uint`), reserve room for future bits
		- Decision: use `uint` for headroom (we already need ~12 bits; `uint` keeps growth cheap).
	- [x] Keep naming consistent: `HasLeadingX` / `HasTrailingX` / `ContainsX`

- [x] Add `Flags` to `GreenNode`
	- [x] Add `internal GreenNodeFlags Flags { get; }`
		- Implemented as `internal virtual GreenNodeFlags Flags => GreenNodeFlags.None;` initially.
		- Phase 2/3 will override in concrete node types after computing flags.
	- [ ] Add lightweight convenience bools (optional)

- [x] Confirm record/equality impact approach
	- [x] Ensure `Flags` is deterministically derived from other fields
		- Decision: flags must be computed solely from trivia/kind/children (no external state).
	- [x] Decide whether `Flags` should participate in record equality (default) or be excluded (custom)
		- Decision: keep default record equality; rely on deterministic computation + Phase 5 tests.

Acceptance criteria:
- Green nodes compile with a flags field/property available from the base type.

------------------------------------------------------------------------

## Phase 2 — Compute Flags in Leaves

- [ ] Update `GreenLeaf` constructor
	- [ ] Scan `LeadingTrivia` once to set boundary flags
	- [ ] Scan `TrailingTrivia` once to set boundary flags
	- [ ] Set subtree flags based on boundary results
	- [ ] Ensure no extra passes beyond existing trivia width computation (piggyback loops)

- [ ] Verify `GreenNodeCache` behavior is still correct
	- [ ] Cached leaves with no trivia have stable flags (`None`)
	- [ ] Cached “trailing space” leaves have whitespace flags but no newline/comment
	- [ ] Leaves with trivia remain non-cached (unchanged behavior)

Acceptance criteria:
- Leaf flags are correct for leading/trailing trivia kinds and don’t add noticeable allocations.

------------------------------------------------------------------------

## Phase 3 — Aggregate Flags in Containers

- [ ] Update `GreenBlock`
	- [ ] OR flags from opener leaf + all inner children + closer leaf
	- [ ] Ensure boundary flags reflect the block’s actual left/right boundaries

- [ ] Update `GreenList`
	- [ ] OR flags from all children
	- [ ] Derive boundary flags from first/last child when present

- [ ] Update `GreenSyntaxNode`
	- [ ] OR flags from all children
	- [ ] Derive boundary flags from first/last child when present

- [ ] Validate structural sharing invariants
	- [ ] `WithSlot`/`WithInsert`/`WithReplace` cause flags to recompute via constructors (no ad-hoc flag mutation)
	- [ ] `WithLeadingTrivia`/`WithTrailingTrivia`/`WithText` on leaves continue to work

Acceptance criteria:
- Container flags correctly reflect subtree + boundary properties and remain deterministic.

------------------------------------------------------------------------

## Phase 4 — Tests: Flag Correctness

- [ ] Add/extend unit tests for flag correctness
	- [ ] Leaf boundary flags
		- [ ] Newline trivia in leading/trailing
		- [ ] Comment trivia in leading/trailing
		- [ ] Whitespace trivia in leading/trailing
	- [ ] Aggregation
		- [ ] Block contains newline/comment/whitespace when present in delimiters or inner children
		- [ ] List/syntax node aggregation
	- [ ] “Newline ownership” sanity (existing lexer trivia semantics)
		- [ ] Newline appears as trailing trivia of previous token in common cases

Acceptance criteria:
- Tests reliably catch flag computation regressions.

------------------------------------------------------------------------

## Phase 5 — Tests: Record Equality / Hash Stability (extra safety)

- [ ] Equality invariants (structural equality)
	- [ ] Construct equivalent green nodes via different construction paths and assert `Equals` is true
	- [ ] Assert `GetHashCode` matches for structurally equal nodes

- [ ] Cache interaction
	- [ ] Cached leaf instances behave consistently (equal nodes produce equal hashes)
	- [ ] Non-cached leaves with identical trivia sequences still compare equal

- [ ] Structural sharing sanity
	- [ ] `With*` methods do not mutate originals
	- [ ] Only content changes cause inequality

Acceptance criteria:
- We have strong confidence that adding `Flags` doesn’t introduce equality/hash surprises.

------------------------------------------------------------------------

## Phase 6 — Validation / Perf Smoke

- [ ] Run `dotnet test TinyTokenizer.Tests`
- [ ] Run `dotnet run -c Release --project TinyTokenizer.Benchmarks -- --filter *AstBenchmarks*`
- [ ] Run `dotnet run -c Release --project TinyTokenizer.Benchmarks -- --filter *SyntaxEditorBenchmarks*`

Acceptance criteria:
- All tests pass; no obvious performance regressions.

------------------------------------------------------------------------

## Follow-up (out of scope for this .todo)

- [ ] Update Query newline matching to use flags (separate plan/work item)
- [ ] Optional: add targeted benchmarks for `SyntaxTree.Select(Query.Newline)` once newline query changes land

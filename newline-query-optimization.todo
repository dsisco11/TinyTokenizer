# Newline Query + Query Engine Optimization Plan

Goal: make `Query.Newline` extremely optimized and semantically correct for "node occurs AFTER a newline",
while reducing allocations/overhead in the hottest Query paths (small scope).

Confirmed semantics:
- "After a newline" means either:
	- The node’s leading trivia contains a newline, OR
	- The previous sibling’s trailing trivia contains a newline.

Constraints:
- Keep change surface minimal: rewrite only the hottest LINQ paths.
- Preserve document order and all existing query semantics.
- Keep newline semantics identical in red matching and green matching.

------------------------------------------------------------------------

## Phase 0 — Baseline + Safety Nets

- [x] Identify current implementation + hotspots
	- [x] Locate `NewlineNodeQuery` and its `TryMatchGreen(...)` implementation
	- [x] Find the selection-mode code path (`SelectModes.Last` / `ApplyMode`)
	- [x] Identify the hottest `Select(...)` implementations/combinators currently using LINQ

- [x] Add/confirm semantic tests for newline behavior
	- [x] Leading trivia newline qualifies as `Query.Newline`
	- [x] Previous sibling trailing trivia newline qualifies as `Query.Newline`
	- [x] Both cases work at top-level and inside blocks
	- [x] `Query.NotNewline` is the exact negation of `Query.Newline` for the same contexts
	- [x] Edge cases: first sibling (no previous sibling), empty blocks/regions

Acceptance criteria:
- Existing behavior is captured in tests so perf refactors don’t change semantics.

------------------------------------------------------------------------

## Phase 1 — Align Newline Semantics (Green Matching)

- [ ] Update green matching for newline
	- [ ] Implement both checks in `NewlineNodeQuery.TryMatchGreen(parent, childIndex, out consumedCount)`:
		- [ ] Current node leading trivia contains newline
		- [ ] Previous sibling trailing trivia contains newline (when `childIndex > 0`)
	- [ ] Use only `(parent, childIndex)` context; do not allocate red siblings
	- [ ] Keep `consumedCount` behavior identical (should remain 1)

- [ ] Validate parity with red matching
	- [ ] Ensure red matching logic (if separate) uses the same semantics
	- [ ] Add a regression test that validates both red and green paths (if both are reachable)

Acceptance criteria:
- `Query.Newline` matches exactly the confirmed semantics in all test cases.

------------------------------------------------------------------------

## Phase 2 — Remove LINQ from Selection Modes (Start with `SelectModes.Last`)

- [ ] Rewrite selection-mode handling without LINQ
	- [ ] Replace `LastOrDefault()` usage with a simple scan that tracks the last match
	- [ ] Ensure ordering/behavior matches existing semantics
	- [ ] Avoid buffering unless semantics strictly require it

- [ ] Expand to other modes only if they are on the hot path
	- [ ] Audit remaining modes for LINQ/buffering
	- [ ] Rewrite only those that show up in profiles/benchmarks

Acceptance criteria:
- `SelectModes.Last` returns the same result as before, with fewer allocations.

------------------------------------------------------------------------

## Phase 3 — Replace LINQ in the Hottest `Select(...)` Implementations (Small Scope)

- [ ] Identify top `Select` hot paths
	- [ ] Common kind queries (e.g., `KindNodeQuery.Select(...)`)
	- [ ] Block queries and leaf queries used heavily by editor/regions

- [ ] Replace common LINQ patterns with tight loops
	- [ ] Replace `.Where(...)`, `.SelectMany(...)`, `.LastOrDefault()` in hot paths
	- [ ] Preserve document order and short-circuiting behavior
	- [ ] Avoid iterator/closure allocations where possible

Acceptance criteria:
- Query results are byte-for-byte identical in ordering and content; allocations reduced in benchmarks.

------------------------------------------------------------------------

## Phase 4 — Replace LINQ in the Hottest Combinators (Small Scope)

- [ ] Remove LINQ where it forces buffering/extra iterators
	- [ ] OR / AnyOf-style combinators
	- [ ] AND / sequence-style combinators
	- [ ] Any other combinator used by newline queries or editor/region resolution

- [ ] Preserve semantics and ordering
	- [ ] Document order remains stable
	- [ ] No duplicate matches unless already part of the semantics

Acceptance criteria:
- Combinator behavior remains unchanged; perf improves in existing suites.

------------------------------------------------------------------------

## Phase 5 — Optimize Region Resolution (Materialize-on-Match)

- [ ] Refactor region traversal to avoid per-visited-node allocations
	- [ ] Maintain an incremental slot-index stack while walking the tree
	- [ ] Construct `NodePath` only when a match is found (snapshot stack)
	- [ ] Avoid `NodePath.FromNode(...)` and repeated `.ToArray()` allocations in scans

- [ ] Validate correctness
	- [ ] Query regions (`IRegionQuery` + match-based fallback) return identical regions
	- [ ] Editor operations that depend on regions remain stable

Acceptance criteria:
- Region-heavy operations allocate less and remain semantically identical.

------------------------------------------------------------------------

## Phase 6 — Documentation Sanity

- [ ] Update docs/comments to explicitly state newline semantics
	- [ ] Clarify "node after newline" definition (leading trivia OR previous sibling trailing trivia)
	- [ ] Remove/correct any mention of "newline whitespace tokens" if newline is trivia-only
	- [ ] Ensure docs match actual implementation

Suggested doc touchpoints:
- [ ] TinyTokenizer.wiki/Query-API.md
- [ ] TinyTokenizer.wiki/Trivia.md
- [ ] TinyTokenizer.wiki/TreeWalker.md (only if it mentions newline semantics)

Acceptance criteria:
- Public docs and XML comments match runtime behavior.

------------------------------------------------------------------------

## Phase 7 — Validation / Perf Smoke

- [ ] Run unit tests
	- [ ] `dotnet test TinyTokenizer.Tests`

- [ ] Run benchmarks (baseline + comparison)
	- [ ] `dotnet run -c Release --project TinyTokenizer.Benchmarks`
	- [ ] Filter relevant suites:
		- [ ] `dotnet run -c Release --project TinyTokenizer.Benchmarks -- --filter *SyntaxTreeBenchmarks*`
		- [ ] `dotnet run -c Release --project TinyTokenizer.Benchmarks -- --filter *SyntaxEditorBenchmarks*`

- [ ] (Optional) Add a targeted benchmark if needed
	- [ ] Benchmark `SyntaxTree.Select(Query.Newline)`
	- [ ] Benchmark `SelectModes.Last` on a newline-heavy query

Acceptance criteria:
- Tests pass; perf smoke shows reduced allocations or faster execution in the affected scenarios.

# Newline Query + Query Engine Optimization Plan

Goal: make `Query.Newline` extremely optimized and semantically correct for "node occurs AFTER a newline",
while reducing allocations/overhead in the hottest Query paths (small scope).

Confirmed semantics:
- "After a newline" means either:
	- The node’s leading trivia contains a newline, OR
	- The previous sibling’s trailing trivia contains a newline.

Implementation note (post node-flags work):
- These semantics are implemented via green-node *boundary* flags (token-centric):
	- `HasLeadingNewline` on the current node, OR
	- `HasTrailingNewline` on the previous sibling.

Constraints:
- Keep change surface minimal: rewrite only the hottest LINQ paths.
- Preserve document order and all existing query semantics.
- Keep newline semantics identical in red matching and green matching.

------------------------------------------------------------------------

## Phase 0 — Baseline + Safety Nets

- [x] Identify current implementation + hotspots
	- [x] Locate `NewlineNodeQuery` and its `TryMatchGreen(...)` implementation
	- [x] Find the selection-mode code path (`SelectModes.Last` / `ApplyMode`)
	- [x] Identify the hottest `Select(...)` implementations/combinators currently using LINQ

- [x] Add/confirm semantic tests for newline behavior
	- [x] Leading trivia newline qualifies as `Query.Newline`
	- [x] Previous sibling trailing trivia newline qualifies as `Query.Newline`
	- [x] Both cases work at top-level and inside blocks
	- [x] `Query.NotNewline` is the exact negation of `Query.Newline` for the same contexts
	- [x] Edge cases: first sibling (no previous sibling), empty blocks/regions

Acceptance criteria:
- Existing behavior is captured in tests so perf refactors don’t change semantics.

------------------------------------------------------------------------

## Phase 1 — Align Newline Semantics (Green Matching)

- [x] Update green matching for newline
	- [x] Implement both checks in `NewlineNodeQuery.TryMatchGreen(parent, childIndex, out consumedCount)`:
		- [x] Current node `HasLeadingNewline`
		- [x] Previous sibling `HasTrailingNewline` (when `childIndex > 0`)
	- [x] Use only `(parent, childIndex)` context; do not allocate red siblings
	- [x] Keep `consumedCount` behavior identical (should remain 1)

- [x] Validate parity with red matching
	- [x] Ensure red matching logic uses the same semantics (leading OR previous sibling trailing)

Acceptance criteria:
- `Query.Newline` matches exactly the confirmed semantics in all test cases.
- Green matching uses boundary flags (`HasLeadingNewline`/`HasTrailingNewline`) and does not scan trivia.

------------------------------------------------------------------------

## Phase 1b — SyntaxEditor Flag Mutation Tests (Green Flags)

Goal: ensure green-node flags remain correct after `SyntaxEditor` mutations and undo/redo.

- [x] Add SyntaxEditor tests that assert *green* flag values after mutations
	- [x] Assert boundary flags (token-centric ownership)
		- [x] `Replace(...)` preserves `HasLeadingNewline` on the replaced token when leading newline trivia is preserved
		- [x] `InsertAfter(...)` with a trailing newline causes the next sibling to match newline semantics via previous sibling `HasTrailingNewline`
		- [x] `Remove(...)` of a token that owns trailing newline removes the `HasTrailingNewline` boundary from the tree
	- [x] Assert subtree "contains" flags remain correct
		- [x] `ContainsNewline` propagates correctly through blocks/lists after insert/replace/remove
	- [x] Undo/Redo restores flag state
		- [x] After `Commit()`, `Undo()` restores the original green flags
		- [x] After `Undo()`, `Redo()` restores the mutated green flags
	- [x] Prefer stable selection + direct assertions
		- [x] Select the target node via `Query`/positions, then assert `node.Green` flags (`GreenNodeFlags`)
		- [ ] (Optional) also assert `Query.Newline` results as a behavioral cross-check

Acceptance criteria:
- Tests directly assert green flag bits (not just query behavior) for the above scenarios.

------------------------------------------------------------------------

## Phase 2 — Remove LINQ from Selection Modes (Start with `SelectModes.Last`)

- [x] Rewrite selection-mode handling without LINQ
	- [x] Replace `LastOrDefault()` usage with a simple scan that tracks the last match
	- [x] Ensure ordering/behavior matches existing semantics
	- [x] Avoid buffering unless semantics strictly require it

- [x] Expand to other modes only if they are on the hot path
	- [x] Audit remaining modes for LINQ/buffering
	- [x] Rewrite only those that show up in profiles/benchmarks

Acceptance criteria:
- `SelectModes.Last` returns the same result as before, with fewer allocations.

------------------------------------------------------------------------

## Phase 3 — Replace LINQ in the Hottest `Select(...)` Implementations (Small Scope)

- [ ] Identify top `Select` hot paths
	- [ ] Common kind queries (e.g., `KindNodeQuery.Select(...)`)
	- [ ] Block queries and leaf queries used heavily by editor/regions

- [ ] Replace common LINQ patterns with tight loops
	- [ ] Replace `.Where(...)`, `.SelectMany(...)`, `.LastOrDefault()` in hot paths
	- [ ] Preserve document order and short-circuiting behavior
	- [ ] Avoid iterator/closure allocations where possible

Acceptance criteria:
- Query results are byte-for-byte identical in ordering and content; allocations reduced in benchmarks.

------------------------------------------------------------------------

## Phase 4 — Replace LINQ in the Hottest Combinators (Small Scope)

- [ ] Remove LINQ where it forces buffering/extra iterators
	- [ ] OR / AnyOf-style combinators
	- [ ] AND / sequence-style combinators
	- [ ] Any other combinator used by newline queries or editor/region resolution

- [ ] Preserve semantics and ordering
	- [ ] Document order remains stable
	- [ ] No duplicate matches unless already part of the semantics

Acceptance criteria:
- Combinator behavior remains unchanged; perf improves in existing suites.

------------------------------------------------------------------------

## Phase 5 — Optimize Region Resolution (Materialize-on-Match)

- [ ] Refactor region traversal to avoid per-visited-node allocations
	- [ ] Maintain an incremental slot-index stack while walking the tree
	- [ ] Construct `NodePath` only when a match is found (snapshot stack)
	- [ ] Avoid `NodePath.FromNode(...)` and repeated `.ToArray()` allocations in scans

- [ ] Validate correctness
	- [ ] Query regions (`IRegionQuery` + match-based fallback) return identical regions
	- [ ] Editor operations that depend on regions remain stable

Acceptance criteria:
- Region-heavy operations allocate less and remain semantically identical.

------------------------------------------------------------------------

## Phase 6 — Documentation Sanity

- [ ] Update docs/comments to explicitly state newline semantics
	- [ ] Clarify "node after newline" definition (leading trivia OR previous sibling trailing trivia)
	- [ ] Remove/correct any mention of "newline whitespace tokens" if newline is trivia-only
	- [ ] Call out token-centric boundary ownership (containers do not "own" boundary newline flags)
	- [ ] Ensure docs match actual implementation

Suggested doc touchpoints:
- [ ] TinyTokenizer.wiki/Query-API.md
- [ ] TinyTokenizer.wiki/Trivia.md
- [ ] TinyTokenizer.wiki/TreeWalker.md (only if it mentions newline semantics)

Acceptance criteria:
- Public docs and XML comments match runtime behavior.

------------------------------------------------------------------------

## Phase 7 — Validation / Perf Smoke

- [ ] Run unit tests
	- [ ] `dotnet test TinyTokenizer.Tests`

- [ ] Run benchmarks (baseline + comparison)
	- [ ] `dotnet run -c Release --project TinyTokenizer.Benchmarks`
	- [ ] Filter relevant suites:
		- [ ] `dotnet run -c Release --project TinyTokenizer.Benchmarks -- --filter *SyntaxTreeBenchmarks*`
		- [ ] `dotnet run -c Release --project TinyTokenizer.Benchmarks -- --filter *SyntaxEditorBenchmarks*`

- [ ] (Optional) Add a targeted benchmark if needed
	- [x] Benchmark `SyntaxTree.Select(Query.Newline)`
	- [ ] Benchmark `SelectModes.Last` on a newline-heavy query

Acceptance criteria:
- Tests pass; perf smoke shows reduced allocations or faster execution in the affected scenarios.

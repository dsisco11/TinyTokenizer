# Token-Centric Newline Flags Refactor Plan

Goal: Make newline-related `GreenNodeFlags` strictly reflect token-centric `Query.Newline` semantics:
- `Query.Newline` matches nodes that FOLLOW after a newline.
- Token-centric definition: newline is detected via:
	- current node leading trivia contains a newline, OR
	- previous sibling trailing trivia contains a newline.
- Avoid container-node “stacked matches” (e.g., `GreenList`, `GreenSyntaxNode` should not match just because their first child starts after a newline).

Primary drivers:
- Flags should be cheap to read (ideally non-virtual field access).
- Flags should have strict meaning; no accidental propagation that changes query semantics.

------------------------------------------------------------------------

## Phase 0 — Baseline + Guardrails

- [x] Confirm intended semantics in tests
	- [x] Add explicit tests proving `Query.Newline` does NOT match container nodes (root list / syntax containers)
		- [x] Example: on "\nfoo", `Query.Newline` matches `foo` token, but NOT `tree.Root`
		- [x] Example (schema/binding): on "\nfoo()" with syntax binding enabled, `Query.Newline` matches the first token after newline, but NOT the bound syntax node container unless it is itself a token/block boundary
	- [x] Add/confirm tests for existing newline cases remain unchanged (top-level + inside blocks)

Acceptance criteria:
- Tests explicitly lock in token-centric behavior (no container matches).

------------------------------------------------------------------------

## Phase 1 — Define Flag Semantics (Strict Meaning)

- [ ] Decide/document strict meaning of newline-related flags
	- [ ] `HasLeadingNewlineTrivia` / `HasTrailingNewlineTrivia`:
		- [ ] MUST mean: this node *owns* newline trivia on its boundary (not inherited from children)
		- [ ] Valid for: `GreenLeaf` trivia boundaries, `GreenBlock` delimiter boundaries
	- [ ] `ContainsNewlineTrivia`:
		- [ ] MUST mean: newline trivia exists anywhere inside the node’s subtree (including children)
	- [ ] Update inline comments in [TinyTokenizer/Ast/GreenNodeFlags.cs] to match this strict meaning

Acceptance criteria:
- “Boundary” flags are never used to represent “first child boundary”.

------------------------------------------------------------------------

## Phase 2 — Fix Boundary Flag Propagation in Container Nodes

- [ ] Stop propagating boundary newline flags from children in container nodes
	- [ ] Update `GreenList` flags computation
		- [ ] Remove: boundary = (first.Flags & LeadingBoundary) | (last.Flags & TrailingBoundary)
		- [ ] Replace with: boundary is always `None` for lists (or only set if list truly owns boundary trivia, which it currently does not)
		- [ ] Keep: `contains` = OR of children `Contains` masks
	- [ ] Update `GreenSyntaxNode` flags computation similarly
		- [ ] Remove boundary propagation from first/last child
		- [ ] Keep contains propagation
	- [ ] Double-check any other `GreenContainer` types that compute flags similarly
		- [ ] Search for `LeadingBoundary` / `TrailingBoundary` usage outside `GreenLeaf`/`GreenBlock`

Acceptance criteria:
- Container nodes no longer report `HasLeadingNewlineTrivia` / `HasTrailingNewlineTrivia` via child propagation.
- New token-centric tests from Phase 0 pass.

------------------------------------------------------------------------

## Phase 3 — Make Flags a Field (Remove Virtual Property Overhead)

- [ ] Refactor `GreenNode.Flags` from virtual property to base field storage
	- [ ] Introduce an `internal readonly GreenNodeFlags Flags;` field in `GreenNode`
	- [ ] Ensure it is set during construction of every concrete green node
	- [ ] Remove `internal virtual GreenNodeFlags Flags => ...` and all overrides
	- [ ] Update constructors:
		- [ ] `GreenLeaf` sets boundary/contains flags based on trivia/kind
		- [ ] `GreenBlock` sets boundary flags based on delimiter trivia, and contains flags across opener/children/closer
		- [ ] `GreenList` and `GreenSyntaxNode` set contains flags (no boundary propagation)
		- [ ] Any other green node types set flags consistently
	- [ ] Ensure any green-node caches/factories still work (e.g., delimiter cache)

Acceptance criteria:
- Flags reads are non-virtual and O(1) field access.
- All tests pass.

------------------------------------------------------------------------

## Phase 4 — Update Newline Query to Use Flags First (No Type Checks)

- [ ] Update `NewlineNodeQuery` to rely on strict flags
	- [ ] `HasGreenNewline(node)` becomes: `(node.Flags & HasLeadingNewlineTrivia) != 0`
	- [ ] `HasPreviousSiblingTrailingNewline(...)` becomes: `(prev.Flags & HasTrailingNewlineTrivia) != 0`
	- [ ] Keep sibling-context logic in `TryMatchGreen` (can’t be encoded as single-node flag)
	- [ ] Confirm no container nodes accidentally match due to flag propagation fixes (Phase 2)

Acceptance criteria:
- `Query.Newline` behavior remains identical for tokens/blocks.
- Token-centric tests confirming “no container matches” pass.

------------------------------------------------------------------------

## Phase 5 — Validate + Perf Smoke

- [ ] Run full tests
	- [ ] `dotnet test TinyTokenizer.Tests`

- [ ] Add/update a targeted micro-benchmark (optional, if needed)
	- [ ] Benchmark `SyntaxTree.Select(Query.Newline)` on newline-heavy source
	- [ ] Benchmark green-path matching (`IGreenNodeQuery.TryMatchGreen`) for newline scanning

Acceptance criteria:
- Tests pass.
- Allocations are reduced (or at least no regression) for newline-heavy selection.

------------------------------------------------------------------------

## Notes / Risks

- Changing boundary propagation semantics may affect any existing code that incorrectly relied on container boundary flags. Any such cases should switch to `ContainsNewlineTrivia` or explicit token queries.
- Making flags a field will require touching most green node constructors; keep the refactor mechanical and well-tested.
